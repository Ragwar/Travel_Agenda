@{
    ViewData["Title"] = "City";
    var apiKey = ViewData["GoogleApiKey"];
    var schedule = ViewBag.Schedule;
    var scheduleId = schedule?.ScheduleId ?? ViewBag.ScheduleId ?? 0;
    var existingCityName = schedule?.CityName ?? "";
    var existingCityLocation = schedule?.PlaceId ?? ""; // This should be the Google Place ID
}
@await Html.PartialAsync("_ProgressFlowChart")
<link rel="stylesheet" href="~/css/City.css" />
<div class="city-layout">
    <div class="city-search-panel">
        <div class="search-container">
            <input type="text" id="searchBox" class="form-control" placeholder="Search for a city" />
            <button id="submitCityButton" class="btn btn-primary">Save City</button>
        </div>

        <h2>Top Locations in <span id="selectedCityName">@(!string.IsNullOrEmpty(existingCityName) ? existingCityName : "...")</span></h2>
        <div id="locations" class="mt-4"></div>
    </div>

    <div class="city-map-panel">
        <div id="cityMap"></div>
    </div>
</div>

<script src="https://maps.googleapis.com/maps/api/js?key=@apiKey&libraries=places,geometry"></script>
<script>
    window.currentProgressStep = 'city';
    const scheduleId = '@scheduleId';
    let selectedPlace = null;
    const googleApiKey = '@apiKey';
    let cityMap;
    let placesService; // Store the places service globally

    // Existing city data from database
    const existingCityName = '@Html.Raw(existingCityName)';
    const existingCityLocation = '@Html.Raw(existingCityLocation)';

    // Make the current schedule available to the progress flowchart
    window.currentSchedule = {
        ScheduleId: @scheduleId,
        CityName: "@(schedule?.CityName ?? "")"
    };

    // Initialize the city map
    function initCityMap() {
        // Default center (can be any location, will be updated when city is selected)
        const defaultCenter = { lat: 40.7128, lng: -74.0060 }; // New York as default

        cityMap = new google.maps.Map(document.getElementById("cityMap"), {
            zoom: 10,
            center: defaultCenter,
            mapTypeControl: true,
            streetViewControl: true,
            fullscreenControl: true
        });

        // Initialize the places service
        placesService = new google.maps.places.PlacesService(cityMap);

        // Load existing city if available
        if (existingCityName && existingCityLocation) {
            loadExistingCity();
        }
    }

    // Load existing city from database
    function loadExistingCity() {
        console.log(`Loading existing city: ${existingCityName} with location: ${existingCityLocation}`);

        // Get place details using the stored place ID
        placesService.getDetails({
            placeId: existingCityLocation,
            fields: ['name', 'place_id', 'geometry', 'formatted_address']
        }, (place, status) => {
            if (status === google.maps.places.PlacesServiceStatus.OK && place) {
                console.log('Successfully loaded existing city details:', place);

                // Set the selected place
                selectedPlace = {
                    name: place.name,
                    placeId: place.place_id,
                    location: place.geometry.location
                };

                // Update the search box with the city name
                document.getElementById("searchBox").value = place.name;

                // Update the city name display
                document.getElementById("selectedCityName").textContent = place.name;

                // Update the map to show the existing city
                updateCityMap(place);

                // Fetch top locations for the existing city
                fetchTopLocations(place.geometry.location, place.geometry.viewport);

                console.log(`Existing city ${place.name} loaded successfully`);
            } else {
                console.error('Failed to load existing city details:', status);
                // Fallback: try to geocode by city name
                if (existingCityName) {
                    geocodeCityByName(existingCityName);
                }
            }
        });
    }

    // Fallback method to geocode by city name if place ID fails
    function geocodeCityByName(cityName) {
        console.log(`Fallback: Geocoding city by name: ${cityName}`);

        const geocoder = new google.maps.Geocoder();
        geocoder.geocode({
            address: cityName,
            componentRestrictions: { country: 'US' } // Adjust country as needed
        }, (results, status) => {
            if (status === 'OK' && results[0]) {
                const place = results[0];

                selectedPlace = {
                    name: cityName,
                    placeId: place.place_id,
                    location: place.geometry.location
                };

                document.getElementById("searchBox").value = cityName;
                document.getElementById("selectedCityName").textContent = cityName;

                // Create a mock place object for updateCityMap
                const mockPlace = {
                    geometry: {
                        location: place.geometry.location,
                        viewport: place.geometry.viewport
                    }
                };

                updateCityMap(mockPlace);
                fetchTopLocations(place.geometry.location, place.geometry.viewport);

                console.log(`Fallback geocoding successful for ${cityName}`);
            } else {
                console.error('Geocoding failed:', status);
            }
        });
    }

    // Update map when city is selected
    function updateCityMap(place) {
        if (!cityMap) return;

        const location = place.geometry.location;
        const viewport = place.geometry.viewport;

        // Fit map to city bounds
        if (viewport) {
            cityMap.fitBounds(viewport);
        } else {
            cityMap.setCenter(location);
            cityMap.setZoom(12);
        }
    }

    // Fast image loader with Google Maps Static API fallback
    class FastImageLoader {
        constructor() {
            this.queue = [];
            this.isProcessing = false;
            this.maxConcurrent = 3;
            this.activeLoads = 0;
            this.loadDelay = 300;
        }

        addToQueue(photoUrl, placeName, placeLocation, container) {
            this.queue.push({ photoUrl, placeName, placeLocation, container });
            this.processQueue();
        }

        async processQueue() {
            if (this.isProcessing || this.queue.length === 0) {
                return;
            }

            this.isProcessing = true;

            while (this.queue.length > 0 && this.activeLoads < this.maxConcurrent) {
                const item = this.queue.shift();
                this.loadImageFast(item);
                await this.delay(this.loadDelay);
            }

            this.isProcessing = false;
        }

        loadImageFast({ photoUrl, placeName, placeLocation, container }) {
            this.activeLoads++;

            const cleanup = () => {
                this.activeLoads--;
                this.processQueue();
            };

            if (photoUrl) {
                const img = new Image();
                let timeoutId;

                const onSuccess = () => {
                    clearTimeout(timeoutId);
                    img.className = 'location-image';
                    img.alt = placeName;

                    container.innerHTML = '';
                    container.appendChild(img);
                    cleanup();
                };

                const onError = () => {
                    clearTimeout(timeoutId);
                    console.log(`Using map view for ${placeName}`);
                    this.createMapView(placeName, placeLocation, container);
                    cleanup();
                };

                timeoutId = setTimeout(onError, 2000);

                img.onload = onSuccess;
                img.onerror = onError;
                img.src = photoUrl;
            } else {
                this.createMapView(placeName, placeLocation, container);
                cleanup();
            }
        }

        createMapView(placeName, placeLocation, container) {
            if (!placeLocation) {
                this.createFallbackImage(placeName, container);
                return;
            }

            // Handle both Google Maps objects and plain objects from service
            const lat = typeof placeLocation.lat === 'function' ? placeLocation.lat() : placeLocation.lat;
            const lng = typeof placeLocation.lng === 'function' ? placeLocation.lng() : placeLocation.lng;

            const mapUrl = `https://maps.googleapis.com/maps/api/staticmap?` +
                `center=${lat},${lng}&` +
                `zoom=17&` +
                `size=100x100&` +
                `maptype=roadmap&` +
                `style=feature:poi|visibility:on&` +
                `style=feature:transit|visibility:simplified&` +
                `key=${googleApiKey}`;

            const img = document.createElement("img");
            img.src = mapUrl;
            img.className = 'map-image';
            img.alt = `Map view of ${placeName}`;
            img.title = `Location: ${placeName}`;

            img.onload = () => {
                container.innerHTML = '';
                container.appendChild(img);
            };

            img.onerror = () => {
                this.createFallbackImage(placeName, container);
            };
        }

        createFallbackImage(placeName, container) {
            container.innerHTML = `<div class="fallback-image">📍</div>`;
        }

        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    const imageLoader = new FastImageLoader();

    function createImageContainer(placeName) {
        const container = document.createElement("div");
        container.className = 'image-container';
        container.innerHTML = `<div class="image-loading">⏳</div>`;
        return container;
    }

    function getOptimizedPhotoUrl(photo) {
        if (!photo) return null;

        try {
            return photo.getUrl({
                maxWidth: 100,
                maxHeight: 100
            });
        } catch (error) {
            console.error('Error getting photo URL:', error);
            return null;
        }
    }

    function isHotel(place) {
        if (!place.types) return false;

        const hotelTypes = [
            'lodging',
            'hotel',
            'resort',
            'hostel',
            'motel',
            'bed_and_breakfast',
            'guest_house',
            'serviced_apartment'
        ];

        return place.types.some(type => hotelTypes.includes(type));
    }

    function filterRestaurants(results) {
        return results.filter(place => {
            if (isHotel(place)) {
                console.log(`Excluding ${place.name} from restaurants (it's a hotel)`);
                return false;
            }
            return true;
        });
    }

    async function fetchTopLocations(location, viewport) {
        const resultsContainer = document.getElementById("locations");
        resultsContainer.innerHTML = "";

        const cityName = selectedPlace ? selectedPlace.name : existingCityName;
        const cityPlaceId = selectedPlace ? selectedPlace.placeId : existingCityLocation;

        console.log(`Searching for top locations in ${cityName}`);

        const categories = [
            { type: "restaurant", name: "🍽️ Restaurants" },
            { type: "lodging", name: "🏨 Hotels" },
            { type: "park", name: "🌳 Parks" },
            { type: "museum", name: "🏛️ Museums" },
            { type: "shopping_mall", name: "🛍️ Shopping" }
        ];

        for (let categoryIndex = 0; categoryIndex < categories.length; categoryIndex++) {
            const category = categories[categoryIndex];

            setTimeout(async () => {
                console.log(`Processing ${category.type} for ${cityName}`);

                const section = document.createElement("div");
                section.classList.add("mt-3");
                section.innerHTML = `
                    <h3>Top ${category.name}</h3>
                    <div class="loading-message">
                        🔍 Searching for ${category.type}s in ${cityName}...
                    </div>
                `;
                resultsContainer.appendChild(section);

                try {
                    const response = await fetch(`/Home/GetTopLocationsByCity?cityPlaceId=${encodeURIComponent(cityPlaceId)}&cityName=${encodeURIComponent(cityName)}&locationType=${category.type}&maxResults=5`);

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const locations = await response.json();

                    const loadingMsg = section.querySelector('.loading-message');
                    if (loadingMsg) loadingMsg.remove();

                    if (locations.length === 0) {
                        section.innerHTML += `<p class="no-results-message">No ${category.type}s found within ${cityName} city limits.</p>`;
                        return;
                    }

                    // Process each location and get place details including photos
                    for (const location of locations) {
                        const item = document.createElement("div");
                        item.className = 'mb-3 location-item';

                        const container = document.createElement("div");
                        container.className = 'location-container';

                        const imageContainer = createImageContainer(location.name);

                        const textDiv = document.createElement("div");
                        const priceDisplay = location.priceLevel ? `<br><small class="location-price">💰 ${'$'.repeat(location.priceLevel)}</small>` : '';

                        textDiv.innerHTML = `
                            <strong>${location.name}</strong>
                            <br>
                            <span class="location-rating">⭐ ${location.rating} (${location.userRatingsTotal.toLocaleString()} reviews)</span><br>
                            <small class="location-address">📍 ${location.formattedAddress || location.vicinity || 'Location available'}</small>
                            ${priceDisplay}
                        `;

                        container.appendChild(imageContainer);
                        container.appendChild(textDiv);
                        item.appendChild(container);
                        section.appendChild(item);

                        // Get place details with photos using Places API
                        placesService.getDetails({
                            placeId: location.placeId,
                            fields: ['photos']
                        }, (place, status) => {
                            if (status === google.maps.places.PlacesServiceStatus.OK && place && place.photos && place.photos.length > 0) {
                                // Use the same photo URL method as residence view
                                const photoUrl = getOptimizedPhotoUrl(place.photos[0]);
                                imageLoader.addToQueue(
                                    photoUrl,
                                    location.name,
                                    location.location,
                                    imageContainer
                                );
                            } else {
                                // No photos available, use map view
                                imageLoader.createMapView(location.name, location.location, imageContainer);
                            }
                        });
                    }

                    console.log(`Found ${locations.length} ${category.type}s within ${cityName} bounds`);

                } catch (error) {
                    console.error(`Error fetching ${category.type}s:`, error);
                    const loadingMsg = section.querySelector('.loading-message');
                    if (loadingMsg) {
                        loadingMsg.textContent = `Error loading ${category.type}s. Please try again.`;
                        loadingMsg.className = 'error-message';
                    }
                }

            }, categoryIndex * 1200);
        }
    }

    function initAutocomplete() {
        const input = document.getElementById("searchBox");

        const autocomplete = new google.maps.places.Autocomplete(input, {
            types: ["(cities)"],
        });

        autocomplete.addListener("place_changed", () => {
            const place = autocomplete.getPlace();

            if (!place.geometry) {
                alert("No details available for the selected location.");
                return;
            }

            selectedPlace = {
                name: place.name,
                placeId: place.place_id,
                location: place.geometry.location
            };

            document.getElementById("selectedCityName").textContent = selectedPlace.name;

            // Update the city map
            updateCityMap(place);

            // Fetch top locations
            fetchTopLocations(selectedPlace.location, place.geometry.viewport);
        });
    }

    document.getElementById("submitCityButton").addEventListener("click", () => {
        if (!selectedPlace) {
            alert("Please select a city before submitting.");
            return;
        }

        if (!scheduleId) {
            alert("Schedule ID is not available.");
            return;
        }

        const payload = {
            ...selectedPlace,
            scheduleId: scheduleId
        };

        fetch('/Home/SaveCity', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (response.ok) {
                 const redirectUrl = `/Home/Residence?scheduleId=${scheduleId}`;
                window.location.href = redirectUrl;
            } else {
                alert("Failed to save city.");
            }
        })
        .catch(error => console.error('Error:', error));
    });

    google.maps.event.addDomListener(window, "load", () => {
        initCityMap();
        initAutocomplete();
    });
</script>