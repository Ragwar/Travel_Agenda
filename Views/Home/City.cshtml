@{
    ViewData["Title"] = "City";
    var apiKey = ViewData["GoogleApiKey"];
    var scheduleId = ViewBag.Schedule.Schedule_Id;
}
@await Html.PartialAsync("_ProgressFlowChart")
<link rel="stylesheet" href="~/css/CalendarCity.css" />
<div class="city-layout">
    <div class="city-search-panel">
        <div class="form-group">
            <input type="text" id="searchBox" class="form-control" placeholder="Search for a city" />
            <button id="submitCityButton" class="btn btn-primary mt-2">Save City</button>
        </div>

        <h2>Top Locations in <span id="selectedCityName">...</span></h2>
        <div id="locations" class="mt-4"></div>
    </div>

    <div class="city-map-panel">
        <div id="cityMap"></div>
        <div id="cityInfo" class="city-info-panel" style="display: none;">
            <h4 id="cityInfoName">City Information</h4>
            <p id="cityInfoAddress"></p>
            <p id="cityInfoCoordinates"></p>
        </div>
    </div>
</div>

<script src="https://maps.googleapis.com/maps/api/js?key=@apiKey&libraries=places,geometry"></script>
<script>
    window.currentProgressStep = 'city';
    const scheduleId = '@scheduleId';
    let selectedPlace = null;
    const googleApiKey = '@apiKey';
    let cityMap;

    // Initialize the city map
    function initCityMap() {
        // Default center (can be any location, will be updated when city is selected)
        const defaultCenter = { lat: 40.7128, lng: -74.0060 }; // New York as default

        cityMap = new google.maps.Map(document.getElementById("cityMap"), {
            zoom: 10,
            center: defaultCenter,
            mapTypeControl: true,
            streetViewControl: true,
            fullscreenControl: true
        });
    }

    // Update map when city is selected
    function updateCityMap(place) {
        if (!cityMap) return;

        const location = place.geometry.location;
        const viewport = place.geometry.viewport;

        // Fit map to city bounds
        if (viewport) {
            cityMap.fitBounds(viewport);
        } else {
            cityMap.setCenter(location);
            cityMap.setZoom(12);
        }
    }

    // Fast image loader with Google Maps Static API fallback
    class FastImageLoader {
        constructor() {
            this.queue = [];
            this.isProcessing = false;
            this.maxConcurrent = 3;
            this.activeLoads = 0;
            this.loadDelay = 300;
        }

        addToQueue(photoUrl, placeName, placeLocation, container) {
            this.queue.push({ photoUrl, placeName, placeLocation, container });
            this.processQueue();
        }

        async processQueue() {
            if (this.isProcessing || this.queue.length === 0) {
                return;
            }

            this.isProcessing = true;

            while (this.queue.length > 0 && this.activeLoads < this.maxConcurrent) {
                const item = this.queue.shift();
                this.loadImageFast(item);
                await this.delay(this.loadDelay);
            }

            this.isProcessing = false;
        }

        loadImageFast({ photoUrl, placeName, placeLocation, container }) {
            this.activeLoads++;

            const cleanup = () => {
                this.activeLoads--;
                this.processQueue();
            };

            if (photoUrl) {
                const img = new Image();
                let timeoutId;

                const onSuccess = () => {
                    clearTimeout(timeoutId);
                    img.className = 'location-image';
                    img.alt = placeName;

                    container.innerHTML = '';
                    container.appendChild(img);
                    cleanup();
                };

                const onError = () => {
                    clearTimeout(timeoutId);
                    console.log(`Using map view for ${placeName}`);
                    this.createMapView(placeName, placeLocation, container);
                    cleanup();
                };

                timeoutId = setTimeout(onError, 2000);

                img.onload = onSuccess;
                img.onerror = onError;
                img.src = photoUrl;
            } else {
                this.createMapView(placeName, placeLocation, container);
                cleanup();
            }
        }

        createMapView(placeName, placeLocation, container) {
            if (!placeLocation) {
                this.createFallbackImage(placeName, container);
                return;
            }

            const lat = placeLocation.lat();
            const lng = placeLocation.lng();

            const mapUrl = `https://maps.googleapis.com/maps/api/staticmap?` +
                `center=${lat},${lng}&` +
                `zoom=17&` +
                `size=100x100&` +
                `maptype=roadmap&` +
                `style=feature:poi|visibility:on&` +
                `style=feature:transit|visibility:simplified&` +
                `key=${googleApiKey}`;

            const img = document.createElement("img");
            img.src = mapUrl;
            img.className = 'map-image';
            img.alt = `Map view of ${placeName}`;
            img.title = `Location: ${placeName}`;

            img.onload = () => {
                container.innerHTML = '';
                container.appendChild(img);
            };

            img.onerror = () => {
                this.createFallbackImage(placeName, container);
            };
        }

        createFallbackImage(placeName, container) {
            container.innerHTML = `<div class="fallback-image">📍</div>`;
        }

        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    const imageLoader = new FastImageLoader();

    function createImageContainer(placeName) {
        const container = document.createElement("div");
        container.className = 'image-container';
        container.innerHTML = `<div class="image-loading">⏳</div>`;
        return container;
    }

    function getOptimizedPhotoUrl(photo) {
        if (!photo) return null;

        try {
            return photo.getUrl({
                maxWidth: 100,
                maxHeight: 100
            });
        } catch (error) {
            console.error('Error getting photo URL:', error);
            return null;
        }
    }

    function isHotel(place) {
        if (!place.types) return false;

        const hotelTypes = [
            'lodging',
            'hotel',
            'resort',
            'hostel',
            'motel',
            'bed_and_breakfast',
            'guest_house',
            'serviced_apartment'
        ];

        return place.types.some(type => hotelTypes.includes(type));
    }

    function filterRestaurants(results) {
        return results.filter(place => {
            if (isHotel(place)) {
                console.log(`Excluding ${place.name} from restaurants (it's a hotel)`);
                return false;
            }
            return true;
        });
    }

    async function fetchTopLocations(location, viewport) {
        const resultsContainer = document.getElementById("locations");
        resultsContainer.innerHTML = "";

        const cityName = selectedPlace.name;
        console.log(`Searching for top locations in ${cityName}`);

        const categories = [
            {
                type: "restaurant",
                searchTerms: [
                    `best restaurants ${cityName}`,
                    `top rated restaurants ${cityName}`,
                    `most popular restaurants ${cityName}`
                ]
            },
            {
                type: "hotel",
                searchTerms: [
                    `best hotels ${cityName}`,
                    `top rated hotels ${cityName}`,
                    `luxury hotels ${cityName}`
                ]
            },
            {
                type: "park",
                searchTerms: [
                    `popular parks ${cityName}`,
                    `best parks ${cityName}`,
                    `top attractions parks ${cityName}`
                ]
            },
            {
                type: "museum",
                searchTerms: [
                    `best museums ${cityName}`,
                    `top museums ${cityName}`,
                    `popular museums ${cityName}`
                ]
            }
        ];

        for (let categoryIndex = 0; categoryIndex < categories.length; categoryIndex++) {
            const category = categories[categoryIndex];

            setTimeout(async () => {
                console.log(`Processing ${category.type} for ${cityName}`);

                const section = document.createElement("div");
                section.classList.add("mt-3");
                section.innerHTML = `
                    <h3>Top ${category.type.charAt(0).toUpperCase() + category.type.slice(1)}s</h3>
                    <div class="loading-message">
                        🔍 Searching for the most reviewed ${category.type}s in ${cityName}...
                    </div>
                `;
                resultsContainer.appendChild(section);

                const service = new google.maps.places.PlacesService(document.createElement("div"));
                let allResults = [];

                const nearbyRequest = {
                    location: location,
                    radius: 15000,
                    type: category.type,
                };

                try {
                    const nearbyResults = await new Promise((resolve) => {
                        service.nearbySearch(nearbyRequest, (results, status) => {
                            if (status === google.maps.places.PlacesServiceStatus.OK) {
                                resolve(results || []);
                            } else {
                                resolve([]);
                            }
                        });
                    });

                    allResults.push(...nearbyResults);

                    for (const searchTerm of category.searchTerms) {
                        const textResults = await new Promise((resolve) => {
                            service.textSearch({
                                query: searchTerm,
                                location: location,
                                radius: 20000
                            }, (results, status) => {
                                if (status === google.maps.places.PlacesServiceStatus.OK) {
                                    resolve(results || []);
                                } else {
                                    resolve([]);
                                }
                            });
                        });

                        allResults.push(...textResults);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }

                    const uniqueResults = allResults.filter((place, index, self) =>
                        index === self.findIndex(p => p.place_id === place.place_id)
                    );

                    let filteredResults = uniqueResults
                        .filter(result => result.rating && result.user_ratings_total && result.user_ratings_total > 10);

                    if (category.type === "restaurant") {
                        filteredResults = filterRestaurants(filteredResults);
                    }

                    filteredResults = filteredResults
                        .sort((a, b) => {
                            const reviewDiff = b.user_ratings_total - a.user_ratings_total;
                            if (Math.abs(reviewDiff) > 50) return reviewDiff;
                            return b.rating - a.rating;
                        });

                    const loadingMsg = section.querySelector('.loading-message');
                    if (loadingMsg) loadingMsg.remove();

                    if (filteredResults.length === 0) {
                        section.innerHTML += `<p class="no-results-message">No highly-reviewed ${category.type}s found in this area.</p>`;
                        return;
                    }

                    const topResults = filteredResults.slice(0, 5);

                    topResults.forEach((result, index) => {
                        const photoUrl = result.photos && result.photos.length > 0
                            ? getOptimizedPhotoUrl(result.photos[0])
                            : null;

                        const item = document.createElement("div");
                        item.className = 'mb-3 location-item';

                        const container = document.createElement("div");
                        container.className = 'location-container';

                        const imageContainer = createImageContainer(result.name);

                        const textDiv = document.createElement("div");
                        const priceDisplay = result.price_level ? `<br><small class="location-price">💰 ${'$'.repeat(result.price_level)}</small>` : '';

                        textDiv.innerHTML = `
                            <strong>${result.name}</strong>
                            <br>
                            <span class="location-rating">⭐ ${result.rating} (${result.user_ratings_total.toLocaleString()} reviews)</span><br>
                            <small class="location-address">📍 ${result.formatted_address || result.vicinity || 'Location available'}</small>
                            ${priceDisplay}
                        `;

                        container.appendChild(imageContainer);
                        container.appendChild(textDiv);
                        item.appendChild(container);
                        section.appendChild(item);

                        imageLoader.addToQueue(
                            photoUrl,
                            result.name,
                            result.geometry.location,
                            imageContainer
                        );
                    });

                    console.log(`Found ${topResults.length} top ${category.type}s for ${cityName}`);

                } catch (error) {
                    console.error(`Error fetching ${category.type}s:`, error);
                    const loadingMsg = section.querySelector('.loading-message');
                    if (loadingMsg) {
                        loadingMsg.textContent = `Error loading ${category.type}s. Please try again.`;
                        loadingMsg.className = 'error-message';
                    }
                }

            }, categoryIndex * 1000);
        }
    }

    function initAutocomplete() {
        const input = document.getElementById("searchBox");

        const autocomplete = new google.maps.places.Autocomplete(input, {
            types: ["(cities)"],
        });

        autocomplete.addListener("place_changed", () => {
            const place = autocomplete.getPlace();

            if (!place.geometry) {
                alert("No details available for the selected location.");
                return;
            }

            selectedPlace = {
                name: place.name,
                placeId: place.place_id,
                location: place.geometry.location
            };

            document.getElementById("selectedCityName").textContent = selectedPlace.name;

            // Update the city map
            updateCityMap(place);

            // Fetch top locations
            fetchTopLocations(selectedPlace.location, place.geometry.viewport);
        });
    }

    document.getElementById("submitCityButton").addEventListener("click", () => {
        if (!selectedPlace) {
            alert("Please select a city before submitting.");
            return;
        }

        if (!scheduleId) {
            alert("Schedule ID is not available.");
            return;
        }

        const payload = {
            ...selectedPlace,
            scheduleId: scheduleId
        };

        fetch('/Home/SaveCity', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (response.ok) {
                const redirectUrl = `/Home/Residence?id=${scheduleId}`;
                window.location.href = redirectUrl;
            } else {
                alert("Failed to save city.");
            }
        })
        .catch(error => console.error('Error:', error));
    });

    google.maps.event.addDomListener(window, "load", () => {
        initCityMap();
        initAutocomplete();
    });
</script>