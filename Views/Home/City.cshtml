@{
    ViewData["Title"] = "City";
    var apiKey = ViewData["GoogleApiKey"];
    var schedule = ViewBag.Schedule;
    var scheduleId = schedule?.Schedule_Id ?? ViewBag.ScheduleId ?? 0;
}
@await Html.PartialAsync("_ProgressFlowChart")
<link rel="stylesheet" href="~/css/CalendarCity.css" />
<div class="city-layout">
    <div class="city-search-panel">
        <div class="form-group">
            <input type="text" id="searchBox" class="form-control" placeholder="Search for a city" />
            <button id="submitCityButton" class="btn btn-primary mt-2">Save City</button>
        </div>

        <h2>Top Locations in <span id="selectedCityName">...</span></h2>
        <div id="locations" class="mt-4"></div>
    </div>

    <div class="city-map-panel">
        <div id="cityMap"></div>
        <div id="cityInfo" class="city-info-panel" style="display: none;">
            <h4 id="cityInfoName">City Information</h4>
            <p id="cityInfoAddress"></p>
            <p id="cityInfoCoordinates"></p>
        </div>
    </div>
</div>

<script src="https://maps.googleapis.com/maps/api/js?key=@apiKey&libraries=places,geometry"></script>
<script>
    window.currentProgressStep = 'city';
    const scheduleId = '@scheduleId';
    let selectedPlace = null;
    const googleApiKey = '@apiKey';
    let cityMap;

    // Make the current schedule available to the progress flowchart
    window.currentSchedule = {
        Schedule_Id: @scheduleId,
        City_Name: "@(schedule?.City_Name ?? "")"
    };

    // Initialize the city map
    function initCityMap() {
        // Default center (can be any location, will be updated when city is selected)
        const defaultCenter = { lat: 40.7128, lng: -74.0060 }; // New York as default

        cityMap = new google.maps.Map(document.getElementById("cityMap"), {
            zoom: 10,
            center: defaultCenter,
            mapTypeControl: true,
            streetViewControl: true,
            fullscreenControl: true
        });
    }

    // Update map when city is selected
    function updateCityMap(place) {
        if (!cityMap) return;

        const location = place.geometry.location;
        const viewport = place.geometry.viewport;

        // Fit map to city bounds
        if (viewport) {
            cityMap.fitBounds(viewport);
        } else {
            cityMap.setCenter(location);
            cityMap.setZoom(12);
        }
    }

    // Fast image loader with Google Maps Static API fallback
    class FastImageLoader {
        constructor() {
            this.queue = [];
            this.isProcessing = false;
            this.maxConcurrent = 3;
            this.activeLoads = 0;
            this.loadDelay = 300;
        }

        addToQueue(photoUrl, placeName, placeLocation, container) {
            this.queue.push({ photoUrl, placeName, placeLocation, container });
            this.processQueue();
        }

        async processQueue() {
            if (this.isProcessing || this.queue.length === 0) {
                return;
            }

            this.isProcessing = true;

            while (this.queue.length > 0 && this.activeLoads < this.maxConcurrent) {
                const item = this.queue.shift();
                this.loadImageFast(item);
                await this.delay(this.loadDelay);
            }

            this.isProcessing = false;
        }

        loadImageFast({ photoUrl, placeName, placeLocation, container }) {
            this.activeLoads++;

            const cleanup = () => {
                this.activeLoads--;
                this.processQueue();
            };

            if (photoUrl) {
                const img = new Image();
                let timeoutId;

                const onSuccess = () => {
                    clearTimeout(timeoutId);
                    img.className = 'location-image';
                    img.alt = placeName;

                    container.innerHTML = '';
                    container.appendChild(img);
                    cleanup();
                };

                const onError = () => {
                    clearTimeout(timeoutId);
                    console.log(`Using map view for ${placeName}`);
                    this.createMapView(placeName, placeLocation, container);
                    cleanup();
                };

                timeoutId = setTimeout(onError, 2000);

                img.onload = onSuccess;
                img.onerror = onError;
                img.src = photoUrl;
            } else {
                this.createMapView(placeName, placeLocation, container);
                cleanup();
            }
        }

        createMapView(placeName, placeLocation, container) {
            if (!placeLocation) {
                this.createFallbackImage(placeName, container);
                return;
            }

            const lat = placeLocation.lat();
            const lng = placeLocation.lng();

            const mapUrl = `https://maps.googleapis.com/maps/api/staticmap?` +
                `center=${lat},${lng}&` +
                `zoom=17&` +
                `size=100x100&` +
                `maptype=roadmap&` +
                `style=feature:poi|visibility:on&` +
                `style=feature:transit|visibility:simplified&` +
                `key=${googleApiKey}`;

            const img = document.createElement("img");
            img.src = mapUrl;
            img.className = 'map-image';
            img.alt = `Map view of ${placeName}`;
            img.title = `Location: ${placeName}`;

            img.onload = () => {
                container.innerHTML = '';
                container.appendChild(img);
            };

            img.onerror = () => {
                this.createFallbackImage(placeName, container);
            };
        }

        createFallbackImage(placeName, container) {
            container.innerHTML = `<div class="fallback-image">📍</div>`;
        }

        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    const imageLoader = new FastImageLoader();

    function createImageContainer(placeName) {
        const container = document.createElement("div");
        container.className = 'image-container';
        container.innerHTML = `<div class="image-loading">⏳</div>`;
        return container;
    }

    function getOptimizedPhotoUrl(photo) {
        if (!photo) return null;

        try {
            return photo.getUrl({
                maxWidth: 100,
                maxHeight: 100
            });
        } catch (error) {
            console.error('Error getting photo URL:', error);
            return null;
        }
    }

    function isHotel(place) {
        if (!place.types) return false;

        const hotelTypes = [
            'lodging',
            'hotel',
            'resort',
            'hostel',
            'motel',
            'bed_and_breakfast',
            'guest_house',
            'serviced_apartment'
        ];

        return place.types.some(type => hotelTypes.includes(type));
    }

    function filterRestaurants(results) {
        return results.filter(place => {
            if (isHotel(place)) {
                console.log(`Excluding ${place.name} from restaurants (it's a hotel)`);
                return false;
            }
            return true;
        });
    }

       async function fetchTopLocations(location, viewport) {
        const resultsContainer = document.getElementById("locations");
        resultsContainer.innerHTML = "";

        const cityName = selectedPlace.name;
        console.log(`Searching for top locations in ${cityName}`);

        // Calculate city bounds and radius more accurately
        const cityBounds = viewport;
        let searchRadius = 5000; // Start with 5km default

        if (cityBounds) {
            // Calculate approximate radius based on viewport bounds
            const ne = cityBounds.getNorthEast();
            const sw = cityBounds.getSouthWest();
            const distance = google.maps.geometry.spherical.computeDistanceBetween(ne, sw);
            searchRadius = Math.min(Math.max(distance / 4, 2000), 10000); // Between 2km and 10km
        }

        const categories = [
            {
                type: "restaurant",
                searchTerms: [
                    `restaurants in ${cityName}`,
                    `dining ${cityName}`,
                    `food ${cityName}`
                ]
            },
            {
                type: "hotel",
                searchTerms: [
                    `hotels in ${cityName}`,
                    `accommodation ${cityName}`,
                    `lodging ${cityName}`
                ]
            },
            {
                type: "park",
                searchTerms: [
                    `parks in ${cityName}`,
                    `attractions ${cityName}`,
                    `recreation ${cityName}`
                ]
            },
            {
                type: "museum",
                searchTerms: [
                    `museums in ${cityName}`,
                    `culture ${cityName}`,
                    `galleries ${cityName}`
                ]
            }
        ];

        // Function to check if a place is within city bounds
        function isWithinCityBounds(place) {
            if (!place.geometry || !place.geometry.location) return false;

            const placeLocation = place.geometry.location;

            // If we have viewport bounds, use them
            if (cityBounds) {
                return cityBounds.contains(placeLocation);
            }

            // Fallback: check distance from city center
            const distance = google.maps.geometry.spherical.computeDistanceBetween(
                location,
                placeLocation
            );

            return distance <= searchRadius;
        }

        // Function to check if place address contains city name
        function addressContainsCity(place) {
            if (!place.formatted_address && !place.vicinity) return false;

            const address = (place.formatted_address || place.vicinity || '').toLowerCase();
            const cityLower = cityName.toLowerCase();

            // Check if city name appears in address
            return address.includes(cityLower);
        }

        for (let categoryIndex = 0; categoryIndex < categories.length; categoryIndex++) {
            const category = categories[categoryIndex];

            setTimeout(async () => {
                console.log(`Processing ${category.type} for ${cityName} with radius ${searchRadius}m`);

                const section = document.createElement("div");
                section.classList.add("mt-3");
                section.innerHTML = `
                    <h3>Top ${category.type.charAt(0).toUpperCase() + category.type.slice(1)}s</h3>
                    <div class="loading-message">
                        🔍 Searching for ${category.type}s in ${cityName}...
                    </div>
                `;
                resultsContainer.appendChild(section);

                const service = new google.maps.places.PlacesService(document.createElement("div"));
                let allResults = [];

                // Use stricter nearby search with calculated radius
                const nearbyRequest = {
                    location: location,
                    radius: searchRadius,
                    type: category.type,
                };

                try {
                    const nearbyResults = await new Promise((resolve) => {
                        service.nearbySearch(nearbyRequest, (results, status) => {
                            if (status === google.maps.places.PlacesServiceStatus.OK) {
                                resolve(results || []);
                            } else {
                                console.log(`Nearby search failed for ${category.type}:`, status);
                                resolve([]);
                            }
                        });
                    });

                    // Filter nearby results to ensure they're within bounds
                    const filteredNearby = nearbyResults.filter(place =>
                        isWithinCityBounds(place) || addressContainsCity(place)
                    );

                    allResults.push(...filteredNearby);

                    // Use more specific text searches
                    for (const searchTerm of category.searchTerms) {
                        const textResults = await new Promise((resolve) => {
                            service.textSearch({
                                query: searchTerm,
                                location: location,
                                radius: searchRadius
                            }, (results, status) => {
                                if (status === google.maps.places.PlacesServiceStatus.OK) {
                                    resolve(results || []);
                                } else {
                                    resolve([]);
                                }
                            });
                        });

                        // Filter text search results more strictly
                        const filteredTextResults = textResults.filter(place => {
                            // Must pass both location and address checks for text search results
                            return (isWithinCityBounds(place) || addressContainsCity(place)) &&
                                   // Additional check: ensure it's not from a completely different city
                                   !place.formatted_address?.toLowerCase().includes('other major city names here');
                        });

                        allResults.push(...filteredTextResults);
                        await new Promise(resolve => setTimeout(resolve, 800)); // Longer delay to respect API limits
                    }

                    // Remove duplicates
                    const uniqueResults = allResults.filter((place, index, self) =>
                        index === self.findIndex(p => p.place_id === place.place_id)
                    );

                    // Apply additional filtering
                    let filteredResults = uniqueResults
                        .filter(result => {
                            // Must have rating and reasonable review count
                            if (!result.rating || !result.user_ratings_total || result.user_ratings_total < 5) {
                                return false;
                            }

                            // Double-check location bounds
                            if (!isWithinCityBounds(result) && !addressContainsCity(result)) {
                                console.log(`Excluding ${result.name} - outside city bounds`);
                                return false;
                            }

                            return true;
                        });

                    // Special filtering for restaurants
                    if (category.type === "restaurant") {
                        filteredResults = filterRestaurants(filteredResults);
                    }

                    // Sort by review count and rating
                    filteredResults = filteredResults
                        .sort((a, b) => {
                            // Prioritize places with more reviews, then by rating
                            const reviewDiff = b.user_ratings_total - a.user_ratings_total;
                            if (Math.abs(reviewDiff) > 100) return reviewDiff;
                            return b.rating - a.rating;
                        });

                    const loadingMsg = section.querySelector('.loading-message');
                    if (loadingMsg) loadingMsg.remove();

                    if (filteredResults.length === 0) {
                        section.innerHTML += `<p class="no-results-message">No ${category.type}s found within ${cityName} city limits.</p>`;
                        return;
                    }

                    const topResults = filteredResults.slice(0, 5);

                    topResults.forEach((result, index) => {
                        const photoUrl = result.photos && result.photos.length > 0
                            ? getOptimizedPhotoUrl(result.photos[0])
                            : null;

                        const item = document.createElement("div");
                        item.className = 'mb-3 location-item';

                        const container = document.createElement("div");
                        container.className = 'location-container';

                        const imageContainer = createImageContainer(result.name);

                        const textDiv = document.createElement("div");
                        const priceDisplay = result.price_level ? `<br><small class="location-price">💰 ${'$'.repeat(result.price_level)}</small>` : '';

                        textDiv.innerHTML = `
                            <strong>${result.name}</strong>
                            <br>
                            <span class="location-rating">⭐ ${result.rating} (${result.user_ratings_total.toLocaleString()} reviews)</span><br>
                            <small class="location-address">📍 ${result.formatted_address || result.vicinity || 'Location available'}</small>
                            ${priceDisplay}
                        `;

                        container.appendChild(imageContainer);
                        container.appendChild(textDiv);
                        item.appendChild(container);
                        section.appendChild(item);

                        imageLoader.addToQueue(
                            photoUrl,
                            result.name,
                            result.geometry.location,
                            imageContainer
                        );
                    });

                    console.log(`Found ${topResults.length} ${category.type}s within ${cityName} bounds`);

                } catch (error) {
                    console.error(`Error fetching ${category.type}s:`, error);
                    const loadingMsg = section.querySelector('.loading-message');
                    if (loadingMsg) {
                        loadingMsg.textContent = `Error loading ${category.type}s. Please try again.`;
                        loadingMsg.className = 'error-message';
                    }
                }

            }, categoryIndex * 1200); // Increased delay between categories
        }
    }
    function initAutocomplete() {
        const input = document.getElementById("searchBox");

        const autocomplete = new google.maps.places.Autocomplete(input, {
            types: ["(cities)"],
        });

        autocomplete.addListener("place_changed", () => {
            const place = autocomplete.getPlace();

            if (!place.geometry) {
                alert("No details available for the selected location.");
                return;
            }

            selectedPlace = {
                name: place.name,
                placeId: place.place_id,
                location: place.geometry.location
            };

            document.getElementById("selectedCityName").textContent = selectedPlace.name;

            // Update the city map
            updateCityMap(place);

            // Fetch top locations
            fetchTopLocations(selectedPlace.location, place.geometry.viewport);
        });
    }

    document.getElementById("submitCityButton").addEventListener("click", () => {
        if (!selectedPlace) {
            alert("Please select a city before submitting.");
            return;
        }

        if (!scheduleId) {
            alert("Schedule ID is not available.");
            return;
        }

        const payload = {
            ...selectedPlace,
            scheduleId: scheduleId
        };

        fetch('/Home/SaveCity', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (response.ok) {
                 const redirectUrl = `/Home/Residence?scheduleId=${scheduleId}`;
                window.location.href = redirectUrl;
            } else {
                alert("Failed to save city.");
            }
        })
        .catch(error => console.error('Error:', error));
    });

    google.maps.event.addDomListener(window, "load", () => {
        initCityMap();
        initAutocomplete();
    });
</script>